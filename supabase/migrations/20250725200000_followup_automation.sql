-- Epic 9, Story 9.3: Automated Follow-up Task Creation Schema

-- Follow-up task templates and rules
CREATE TABLE followup_templates (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  \n  -- Template identification\n  template_name VARCHAR(255) NOT NULL,\n  template_type VARCHAR(100) NOT NULL, -- 'completion_followup', 'deadline_reminder', 'dependency_chain', 'recurring_review'\n  description TEXT,\n  \n  -- Template configuration\n  trigger_conditions JSONB NOT NULL, -- Conditions that activate this template\n  followup_config JSONB NOT NULL, -- How to create the follow-up task\n  \n  -- Timing configuration\n  delay_amount INTEGER DEFAULT 0, -- How long to wait (in units)\n  delay_unit VARCHAR(20) DEFAULT 'hours', -- 'minutes', 'hours', 'days', 'weeks'\n  \n  -- Task creation settings\n  inherit_properties JSONB DEFAULT '[]', -- Which properties to inherit from trigger task\n  default_priority VARCHAR(20) DEFAULT 'medium',\n  default_complexity VARCHAR(20) DEFAULT 'simple',\n  \n  -- Status and performance\n  is_active BOOLEAN DEFAULT true,\n  times_triggered INTEGER DEFAULT 0,\n  success_rate DECIMAL(3,2),\n  \n  created_at TIMESTAMPTZ DEFAULT now(),\n  updated_at TIMESTAMPTZ DEFAULT now(),\n  \n  UNIQUE(user_id, template_name),\n  INDEX(user_id, template_type, is_active)\n);\n\n-- Automated follow-up task instances\nCREATE TABLE automated_followups (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  template_id UUID REFERENCES followup_templates(id) ON DELETE SET NULL,\n  trigger_task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,\n  \n  -- Follow-up task details\n  followup_title VARCHAR(255) NOT NULL,\n  followup_description TEXT,\n  followup_priority VARCHAR(20) DEFAULT 'medium',\n  followup_complexity VARCHAR(20) DEFAULT 'simple',\n  followup_category_id UUID REFERENCES categories(id),\n  followup_project_id UUID REFERENCES projects(id),\n  \n  -- Scheduling\n  scheduled_for TIMESTAMPTZ NOT NULL,\n  created_task_id UUID REFERENCES tasks(id), -- NULL until task is created\n  \n  -- Processing status\n  status VARCHAR(50) DEFAULT 'scheduled', -- 'scheduled', 'created', 'cancelled', 'failed'\n  processing_notes TEXT,\n  \n  -- User interaction\n  user_cancelled BOOLEAN DEFAULT false,\n  cancellation_reason TEXT,\n  \n  created_at TIMESTAMPTZ DEFAULT now(),\n  processed_at TIMESTAMPTZ,\n  \n  INDEX(user_id, status),\n  INDEX(scheduled_for),\n  INDEX(trigger_task_id)\n);\n\n-- Task dependency relationships\nCREATE TABLE task_dependencies (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  \n  -- Dependency relationship\n  dependent_task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,\n  prerequisite_task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,\n  \n  -- Dependency configuration\n  dependency_type VARCHAR(100) DEFAULT 'blocks', -- 'blocks', 'enables', 'informs', 'follows'\n  strictness VARCHAR(50) DEFAULT 'hard', -- 'hard', 'soft', 'suggestion'\n  \n  -- Automation behavior\n  auto_unblock BOOLEAN DEFAULT true, -- Auto-enable dependent task when prerequisite completes\n  notification_enabled BOOLEAN DEFAULT true,\n  \n  -- Status tracking\n  is_active BOOLEAN DEFAULT true,\n  resolved_at TIMESTAMPTZ, -- When dependency was satisfied\n  \n  created_at TIMESTAMPTZ DEFAULT now(),\n  \n  UNIQUE(dependent_task_id, prerequisite_task_id),\n  INDEX(user_id, dependent_task_id),\n  INDEX(prerequisite_task_id, is_active)\n);\n\n-- Follow-up suggestion history\nCREATE TABLE followup_suggestions (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  source_task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,\n  \n  -- Suggestion details\n  suggested_title VARCHAR(255) NOT NULL,\n  suggested_description TEXT,\n  suggested_priority VARCHAR(20),\n  suggested_complexity VARCHAR(20),\n  suggestion_reasoning TEXT,\n  confidence_score DECIMAL(3,2) NOT NULL,\n  \n  -- Suggestion context\n  suggestion_type VARCHAR(100) NOT NULL, -- 'completion_followup', 'related_task', 'review_reminder'\n  trigger_event VARCHAR(100) NOT NULL, -- 'task_completed', 'deadline_approaching', 'pattern_detected'\n  context_data JSONB DEFAULT '{}',\n  \n  -- User response\n  status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'accepted', 'rejected', 'dismissed'\n  user_feedback TEXT,\n  created_task_id UUID REFERENCES tasks(id),\n  \n  suggested_at TIMESTAMPTZ DEFAULT now(),\n  responded_at TIMESTAMPTZ,\n  expires_at TIMESTAMPTZ DEFAULT (now() + INTERVAL '7 days'),\n  \n  INDEX(user_id, status),\n  INDEX(source_task_id),\n  INDEX(suggested_at)\n);\n\n-- Follow-up automation jobs\nCREATE TABLE followup_automation_jobs (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  \n  -- Job details\n  job_type VARCHAR(50) NOT NULL, -- 'process_followups', 'check_dependencies', 'generate_suggestions'\n  job_data JSONB NOT NULL,\n  \n  -- Processing status\n  status VARCHAR(50) DEFAULT 'pending', -- 'pending', 'running', 'completed', 'failed'\n  started_at TIMESTAMPTZ,\n  completed_at TIMESTAMPTZ,\n  \n  -- Results\n  tasks_processed INTEGER DEFAULT 0,\n  followups_created INTEGER DEFAULT 0,\n  suggestions_generated INTEGER DEFAULT 0,\n  errors_count INTEGER DEFAULT 0,\n  error_details JSONB DEFAULT '[]',\n  \n  created_at TIMESTAMPTZ DEFAULT now(),\n  \n  INDEX(user_id, status),\n  INDEX(status, created_at)\n);\n\n-- Create indexes for performance\nCREATE INDEX idx_followup_templates_user_type ON followup_templates(user_id, template_type, is_active);\nCREATE INDEX idx_automated_followups_scheduled ON automated_followups(scheduled_for) WHERE status = 'scheduled';\nCREATE INDEX idx_task_dependencies_dependent ON task_dependencies(dependent_task_id, is_active);\nCREATE INDEX idx_followup_suggestions_expires ON followup_suggestions(expires_at) WHERE status = 'pending';\n\n-- Enable RLS\nALTER TABLE followup_templates ENABLE ROW LEVEL SECURITY;\nALTER TABLE automated_followups ENABLE ROW LEVEL SECURITY;\nALTER TABLE task_dependencies ENABLE ROW LEVEL SECURITY;\nALTER TABLE followup_suggestions ENABLE ROW LEVEL SECURITY;\nALTER TABLE followup_automation_jobs ENABLE ROW LEVEL SECURITY;\n\n-- RLS Policies\nCREATE POLICY \"Users can manage their own followup templates\" ON followup_templates\n  FOR ALL USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can view their own automated followups\" ON automated_followups\n  FOR ALL USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can manage their own task dependencies\" ON task_dependencies\n  FOR ALL USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can view their own followup suggestions\" ON followup_suggestions\n  FOR ALL USING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can view their own automation jobs\" ON followup_automation_jobs\n  FOR ALL USING (auth.uid() = user_id);\n\n-- Function to create follow-up task from template\nCREATE OR REPLACE FUNCTION create_followup_from_template(\n  p_template_id UUID,\n  p_trigger_task_id UUID,\n  p_user_id UUID\n)\nRETURNS UUID AS $$\nDECLARE\n  v_template RECORD;\n  v_trigger_task RECORD;\n  v_followup_id UUID;\n  v_scheduled_for TIMESTAMPTZ;\n  v_followup_title VARCHAR(255);\n  v_followup_description TEXT;\n  v_followup_priority VARCHAR(20);\n  v_followup_complexity VARCHAR(20);\nBEGIN\n  -- Get template details\n  SELECT * INTO v_template FROM followup_templates \n  WHERE id = p_template_id AND user_id = p_user_id AND is_active = true;\n  \n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Template not found or inactive';\n  END IF;\n  \n  -- Get trigger task details\n  SELECT * INTO v_trigger_task FROM tasks \n  WHERE id = p_trigger_task_id AND user_id = p_user_id;\n  \n  IF NOT FOUND THEN\n    RAISE EXCEPTION 'Trigger task not found';\n  END IF;\n  \n  -- Calculate scheduled time\n  CASE v_template.delay_unit\n    WHEN 'minutes' THEN v_scheduled_for := now() + (v_template.delay_amount || ' minutes')::INTERVAL;\n    WHEN 'hours' THEN v_scheduled_for := now() + (v_template.delay_amount || ' hours')::INTERVAL;\n    WHEN 'days' THEN v_scheduled_for := now() + (v_template.delay_amount || ' days')::INTERVAL;\n    WHEN 'weeks' THEN v_scheduled_for := now() + (v_template.delay_amount || ' weeks')::INTERVAL;\n    ELSE v_scheduled_for := now();\n  END CASE;\n  \n  -- Generate follow-up task details from template and trigger task\n  v_followup_title := COALESCE(\n    v_template.followup_config->>'title_template',\n    'Follow up on: ' || v_trigger_task.title\n  );\n  \n  v_followup_description := COALESCE(\n    v_template.followup_config->>'description_template',\n    'Automated follow-up for: ' || v_trigger_task.title\n  );\n  \n  -- Inherit properties if configured\n  v_followup_priority := CASE \n    WHEN 'priority' = ANY(SELECT jsonb_array_elements_text(v_template.inherit_properties))\n    THEN v_trigger_task.priority\n    ELSE v_template.default_priority\n  END;\n  \n  v_followup_complexity := CASE \n    WHEN 'complexity' = ANY(SELECT jsonb_array_elements_text(v_template.inherit_properties))\n    THEN v_trigger_task.complexity\n    ELSE v_template.default_complexity\n  END;\n  \n  -- Create automated followup record\n  INSERT INTO automated_followups (\n    user_id, template_id, trigger_task_id,\n    followup_title, followup_description, followup_priority, followup_complexity,\n    followup_category_id, followup_project_id, scheduled_for\n  ) VALUES (\n    p_user_id, p_template_id, p_trigger_task_id,\n    v_followup_title, v_followup_description, v_followup_priority, v_followup_complexity,\n    CASE \n      WHEN 'category_id' = ANY(SELECT jsonb_array_elements_text(v_template.inherit_properties))\n      THEN v_trigger_task.category_id\n      ELSE NULL\n    END,\n    CASE \n      WHEN 'project_id' = ANY(SELECT jsonb_array_elements_text(v_template.inherit_properties))\n      THEN v_trigger_task.project_id\n      ELSE NULL\n    END,\n    v_scheduled_for\n  ) RETURNING id INTO v_followup_id;\n  \n  -- Update template usage stats\n  UPDATE followup_templates SET\n    times_triggered = times_triggered + 1,\n    updated_at = now()\n  WHERE id = p_template_id;\n  \n  RETURN v_followup_id;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to process scheduled follow-ups\nCREATE OR REPLACE FUNCTION process_scheduled_followups(\n  p_limit INTEGER DEFAULT 50\n)\nRETURNS INTEGER AS $$\nDECLARE\n  v_followup RECORD;\n  v_task_id UUID;\n  v_processed_count INTEGER := 0;\nBEGIN\n  -- Process due follow-ups\n  FOR v_followup IN\n    SELECT * FROM automated_followups\n    WHERE status = 'scheduled'\n    AND scheduled_for <= now()\n    AND user_cancelled = false\n    ORDER BY scheduled_for ASC\n    LIMIT p_limit\n  LOOP\n    BEGIN\n      -- Create the actual task\n      INSERT INTO tasks (\n        user_id, title, description, priority, complexity,\n        category_id, project_id, status, source, source_metadata\n      ) VALUES (\n        v_followup.user_id, v_followup.followup_title, v_followup.followup_description,\n        v_followup.followup_priority, v_followup.followup_complexity,\n        v_followup.followup_category_id, v_followup.followup_project_id, 'todo', 'automated_followup',\n        jsonb_build_object(\n          'followup_id', v_followup.id,\n          'template_id', v_followup.template_id,\n          'trigger_task_id', v_followup.trigger_task_id\n        )\n      ) RETURNING id INTO v_task_id;\n      \n      -- Update followup record\n      UPDATE automated_followups SET\n        status = 'created',\n        created_task_id = v_task_id,\n        processed_at = now()\n      WHERE id = v_followup.id;\n      \n      v_processed_count := v_processed_count + 1;\n      \n    EXCEPTION WHEN OTHERS THEN\n      -- Mark as failed and continue\n      UPDATE automated_followups SET\n        status = 'failed',\n        processing_notes = SQLERRM,\n        processed_at = now()\n      WHERE id = v_followup.id;\n    END;\n  END LOOP;\n  \n  RETURN v_processed_count;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to check and resolve task dependencies\nCREATE OR REPLACE FUNCTION check_task_dependencies(\n  p_completed_task_id UUID,\n  p_user_id UUID\n)\nRETURNS INTEGER AS $$\nDECLARE\n  v_dependency RECORD;\n  v_resolved_count INTEGER := 0;\nBEGIN\n  -- Find all dependencies where this task was a prerequisite\n  FOR v_dependency IN\n    SELECT td.*, t.title as dependent_task_title\n    FROM task_dependencies td\n    JOIN tasks t ON t.id = td.dependent_task_id\n    WHERE td.prerequisite_task_id = p_completed_task_id\n    AND td.user_id = p_user_id\n    AND td.is_active = true\n    AND td.resolved_at IS NULL\n  LOOP\n    -- Mark dependency as resolved\n    UPDATE task_dependencies SET\n      resolved_at = now()\n    WHERE id = v_dependency.id;\n    \n    -- If auto-unblock is enabled, update dependent task status\n    IF v_dependency.auto_unblock AND v_dependency.dependency_type = 'blocks' THEN\n      UPDATE tasks SET\n        status = CASE \n          WHEN status = 'blocked' THEN 'todo'\n          ELSE status\n        END,\n        updated_at = now()\n      WHERE id = v_dependency.dependent_task_id\n      AND user_id = p_user_id;\n    END IF;\n    \n    v_resolved_count := v_resolved_count + 1;\n  END LOOP;\n  \n  RETURN v_resolved_count;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to generate follow-up suggestions\nCREATE OR REPLACE FUNCTION generate_followup_suggestions(\n  p_user_id UUID,\n  p_trigger_task_id UUID,\n  p_trigger_event VARCHAR(100)\n)\nRETURNS INTEGER AS $$\nDECLARE\n  v_trigger_task RECORD;\n  v_suggestion_count INTEGER := 0;\n  v_user_patterns JSONB;\nBEGIN\n  -- Get trigger task details\n  SELECT * INTO v_trigger_task FROM tasks \n  WHERE id = p_trigger_task_id AND user_id = p_user_id;\n  \n  IF NOT FOUND THEN\n    RETURN 0;\n  END IF;\n  \n  -- Get user behavior patterns\n  SELECT jsonb_agg(\n    jsonb_build_object(\n      'pattern_type', pattern_type,\n      'pattern_data', pattern_data\n    )\n  ) INTO v_user_patterns\n  FROM user_behavior_patterns\n  WHERE user_id = p_user_id AND confidence_level > 0.6;\n  \n  -- Generate suggestions based on trigger event\n  CASE p_trigger_event\n    WHEN 'task_completed' THEN\n      -- Suggest completion follow-ups\n      INSERT INTO followup_suggestions (\n        user_id, source_task_id, suggested_title, suggested_description,\n        suggested_priority, suggested_complexity, suggestion_reasoning,\n        confidence_score, suggestion_type, trigger_event, context_data\n      ) VALUES (\n        p_user_id, p_trigger_task_id,\n        'Review outcome of: ' || v_trigger_task.title,\n        'Review and document the results of completing \"' || v_trigger_task.title || '\"',\n        'low', 'simple',\n        'Tasks often benefit from outcome review to capture lessons learned',\n        0.75, 'completion_followup', p_trigger_event,\n        jsonb_build_object('completed_task', v_trigger_task.title)\n      );\n      \n      v_suggestion_count := v_suggestion_count + 1;\n      \n    WHEN 'deadline_approaching' THEN\n      -- Suggest preparation tasks\n      INSERT INTO followup_suggestions (\n        user_id, source_task_id, suggested_title, suggested_description,\n        suggested_priority, suggested_complexity, suggestion_reasoning,\n        confidence_score, suggestion_type, trigger_event, context_data\n      ) VALUES (\n        p_user_id, p_trigger_task_id,\n        'Prepare for: ' || v_trigger_task.title,\n        'Gather resources and prepare for completing \"' || v_trigger_task.title || '\"',\n        v_trigger_task.priority, 'simple',\n        'Preparation often improves task completion success rate',\n        0.70, 'preparation_task', p_trigger_event,\n        jsonb_build_object('approaching_task', v_trigger_task.title)\n      );\n      \n      v_suggestion_count := v_suggestion_count + 1;\n      \n    ELSE\n      -- Default: no suggestions for other events\n      NULL;\n  END CASE;\n  \n  RETURN v_suggestion_count;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Insert default follow-up templates for new users\nINSERT INTO followup_templates (user_id, template_name, template_type, description, trigger_conditions, followup_config, delay_amount, delay_unit)\nSELECT \n  id as user_id,\n  'Completion Review',\n  'completion_followup',\n  'Automatically create review tasks when important tasks are completed',\n  '{\"task_completed\": true, \"priority\": [\"high\", \"urgent\"]}',\n  '{\"title_template\": \"Review outcome of: {trigger_task.title}\", \"description_template\": \"Review and document results from {trigger_task.title}\"}',\n  24,\n  'hours'\nFROM auth.users\nWHERE id NOT IN (SELECT user_id FROM followup_templates WHERE template_name = 'Completion Review');\n\n-- Function to trigger follow-up automation when tasks are completed\nCREATE OR REPLACE FUNCTION trigger_followup_automation()\nRETURNS TRIGGER AS $$\nBEGIN\n  -- Only trigger for completed tasks\n  IF NEW.status = 'completed' AND OLD.status != 'completed' THEN\n    -- Check dependencies\n    PERFORM check_task_dependencies(NEW.id, NEW.user_id);\n    \n    -- Generate follow-up suggestions\n    PERFORM generate_followup_suggestions(NEW.user_id, NEW.id, 'task_completed');\n    \n    -- Check for applicable templates and create follow-ups\n    INSERT INTO automated_followups (user_id, template_id, trigger_task_id, followup_title, followup_description, followup_priority, followup_complexity, scheduled_for)\n    SELECT \n      NEW.user_id,\n      ft.id,\n      NEW.id,\n      COALESCE(ft.followup_config->>'title_template', 'Follow up on: ' || NEW.title),\n      COALESCE(ft.followup_config->>'description_template', 'Automated follow-up for: ' || NEW.title),\n      ft.default_priority,\n      ft.default_complexity,\n      now() + (ft.delay_amount || ' ' || ft.delay_unit)::INTERVAL\n    FROM followup_templates ft\n    WHERE ft.user_id = NEW.user_id\n    AND ft.is_active = true\n    AND ft.template_type = 'completion_followup'\n    AND (\n      ft.trigger_conditions->>'task_completed' = 'true'\n      AND (\n        ft.trigger_conditions->'priority' IS NULL\n        OR NEW.priority = ANY(SELECT jsonb_array_elements_text(ft.trigger_conditions->'priority'))\n      )\n    );\n  END IF;\n  \n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Create trigger for automatic follow-up creation\nCREATE TRIGGER trigger_task_followup_automation\n  AFTER UPDATE ON tasks\n  FOR EACH ROW\n  EXECUTE FUNCTION trigger_followup_automation();